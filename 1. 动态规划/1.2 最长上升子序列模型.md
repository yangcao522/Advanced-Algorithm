<font face="华文楷体">
1.最长上升子序列

```java
private static int lds(int[] arr) {
    int L = arr.length;
    int[] dp = new int[L];
    int ans = 0;
    for (int i = 0; i < L; i ++) {
        dp[i] = 1;
        for (int j = 0; j < i; j ++) {
            if (arr[i] <= arr[j]) {
                dp[i] = Math.max(dp[i], 1 + dp[j]);
            }
        }
        ans = Math.max(ans, dp[i]);
    }
    return ans;
}
```

2.最少非增子序列覆盖整个序列
- Dilworth定理: 偏序集的最少反链划分数等于最长链的长度
- 说人话: 最少多少单调非增子序列可以构成整个序列 <=> 序列的最长上升子序列

贪心法：
`g[i]`表示: 已有的单调非增子序列的结尾元素。
当遇到`arr[i]`时，我们贪心的选择最小的结尾元素`>=arr[i]`的那个subsequence来append，假如找不到这么一个结尾元素，我们就让这个`arr[i]`自成一个新的。那么简单推导，`g[N]`数组就是一个单调递增的数组。这个过程和贪心法求最长上升子序列是一模一样的，只是思考的过程不同。
```java
private static int lis(int[] arr) {
    int L = arr.length;
    int cnt = 0;
    int[] g = new int[L];
    for (int i = 0; i < L; i ++) {
        int j = 0;
        while (j < cnt && arr[i] > g[j]) {
            j ++;
        }
        g[j] = arr[i];
        if (j == cnt) cnt ++;
    }
    return cnt;
}
```

3.最少的递增子序列和递减子序列能够覆盖整个序列

这个是在 2.最少非增子序列覆盖整个序列 基础上的衍生。我们需要通过枚举的方法暴力搜索。
1. 当前元素放入单调递增子序列集合中，通过2的分析，我们使用贪心的思想，也就说找到第一个结尾元素比当前元素小的序列。
2. 当前元素放入单调递减子序列集合中，通过2的分析，我们使用贪心的思想，也就说找到第一个结尾元素比当前元素大的序列。

```java
import java.util.*;

class Main {
    static int[] up = new int[60];
    static int[] down = new int[60];

    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        while (scan.hasNext()) {
            int N = scan.nextInt();
            if (N == 0) break;
            int[] arr = new int[N];
            for (int i = 0; i < N; i ++) {
                arr[i] = scan.nextInt();
            }
            int depth = 0;
            while (!dfs(arr, 0, 0, 0, depth)) {
                depth ++;
            }
            System.out.println(depth);
        }
    }

    //迭代加深找最小值
    public static boolean dfs(int[] arr, int u, int su, int sd, int depth) {
        if (su + sd > depth) return false;
        if (u == arr.length) return true;

        boolean flag = false;
        for (int i = 1; i <= su; i ++) {
            if (up[i] < arr[u]) {
                int tmp = up[i];
                up[i] = arr[u];
                if (dfs(arr, u + 1, su, sd, depth)) return true;
                up[i] = tmp;
                flag = true;
                break;
            }
        }

        if (!flag) {
            up[su + 1] = arr[u];
            if (dfs(arr, u + 1, su + 1, sd, depth)) return true;
            up[su + 1] = 0;
        }

        flag = false;

        for (int i = 1; i <= sd; i ++) {
            if (down[i] > arr[u]) {
                int tmp = down[i];
                down[i] = arr[u];
                if (dfs(arr, u + 1, su, sd, depth)) return true;
                down[i] = tmp;
                flag = true;
                break;
            }
        }

        if (!flag) {
            down[sd + 1] = arr[u];
            if (dfs(arr, u + 1, su, sd + 1, depth)) return true;
            down[sd + 1] = 0;
        }

        return false;
    }
}
```
</font>
